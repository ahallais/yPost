package sfv

import (
	"bufio"
	"fmt"
	"hash/crc32"
	"io"
	"os"
	"path/filepath"
	"strings"
)

// Generator handles SFV checksum file generation
type Generator struct {
	outputDir string
}

// NewGenerator creates a new SFV generator
func NewGenerator(outputDir string) *Generator {
	return &Generator{
		outputDir: outputDir,
	}
}

// CreateSFV creates an SFV file for the given file(s)
func (g *Generator) CreateSFV(filePaths []string, sfvName string) (string, error) {
	if err := os.MkdirAll(g.outputDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create output directory: %w", err)
	}

	sfvPath := filepath.Join(g.outputDir, sfvName)
	file, err := os.Create(sfvPath)
	if err != nil {
		return "", fmt.Errorf("failed to create SFV file: %w", err)
	}
	defer file.Close()

	writer := bufio.NewWriter(file)
	defer writer.Flush()

	// Write SFV header
	_, err = writer.WriteString("; Generated by Usenet Poster\n")
	if err != nil {
		return "", fmt.Errorf("failed to write SFV header: %w", err)
	}

	// Calculate and write checksums for each file
	for _, filePath := range filePaths {
		checksum, err := g.calculateCRC32(filePath)
		if err != nil {
			return "", fmt.Errorf("failed to calculate checksum for %s: %w", filePath, err)
		}

		// Use relative path for SFV entry
		relPath, err := filepath.Rel(g.outputDir, filePath)
		if err != nil {
			relPath = filepath.Base(filePath)
		}

		_, err = writer.WriteString(fmt.Sprintf("%s %08X\n", relPath, checksum))
		if err != nil {
			return "", fmt.Errorf("failed to write SFV entry: %w", err)
		}
	}

	return sfvPath, nil
}

// calculateCRC32 calculates the CRC32 checksum of a file
func (g *Generator) calculateCRC32(filePath string) (uint32, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return 0, fmt.Errorf("failed to open file: %w", err)
	}
	defer file.Close()

	hash := crc32.NewIEEE()
	if _, err := io.Copy(hash, file); err != nil {
		return 0, fmt.Errorf("failed to calculate CRC32: %w", err)
	}

	return hash.Sum32(), nil
}

// VerifySFV verifies files against an SFV file
func (g *Generator) VerifySFV(sfvPath string) (bool, error) {
	file, err := os.Open(sfvPath)
	if err != nil {
		return false, fmt.Errorf("failed to open SFV file: %w", err)
	}
	defer file.Close()

	sfvDir := filepath.Dir(sfvPath)
	scanner := bufio.NewScanner(file)
	
	allValid := true
	
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		
		// Skip empty lines and comments
		if line == "" || strings.HasPrefix(line, ";") || strings.HasPrefix(line, "#") {
			continue
		}
		
		// Parse SFV entry
		parts := strings.Fields(line)
		if len(parts) != 2 {
			continue
		}
		
		fileName := parts[0]
		expectedChecksum := parts[1]
		
		// Calculate actual checksum
		fullPath := filepath.Join(sfvDir, fileName)
		actualChecksum, err := g.calculateCRC32(fullPath)
		if err != nil {
			return false, fmt.Errorf("failed to verify %s: %w", fileName, err)
		}
		
		// Compare checksums
		actualHex := fmt.Sprintf("%08X", actualChecksum)
		if strings.ToUpper(actualHex) != strings.ToUpper(expectedChecksum) {
			allValid = false
		}
	}
	
	if err := scanner.Err(); err != nil {
		return false, fmt.Errorf("failed to read SFV file: %w", err)
	}
	
	return allValid, nil
}

// CreateSFVForDirectory creates an SFV file for all files in a directory
func (g *Generator) CreateSFVForDirectory(dirPath string, recursive bool) (string, error) {
	var filePaths []string
	
	err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		
		if !info.IsDir() && !strings.HasSuffix(strings.ToLower(info.Name()), ".sfv") {
			filePaths = append(filePaths, path)
		}
		
		if !recursive && info.IsDir() && path != dirPath {
			return filepath.SkipDir
		}
		
		return nil
	})
	
	if err != nil {
		return "", fmt.Errorf("failed to walk directory: %w", err)
	}
	
	if len(filePaths) == 0 {
		return "", fmt.Errorf("no files found in directory")
	}
	
	sfvName := fmt.Sprintf("%s.sfv", filepath.Base(dirPath))
	return g.CreateSFV(filePaths, sfvName)
}

// ReadSFV reads an SFV file and returns the checksums
func (g *Generator) ReadSFV(sfvPath string) (map[string]string, error) {
	file, err := os.Open(sfvPath)
	if err != nil {
		return nil, fmt.Errorf("failed to open SFV file: %w", err)
	}
	defer file.Close()

	checksums := make(map[string]string)
	scanner := bufio.NewScanner(file)
	
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		
		// Skip empty lines and comments
		if line == "" || strings.HasPrefix(line, ";") || strings.HasPrefix(line, "#") {
			continue
		}
		
		// Parse SFV entry
		parts := strings.Fields(line)
		if len(parts) != 2 {
			continue
		}
		
		fileName := parts[0]
		checksum := parts[1]
		checksums[fileName] = checksum
	}
	
	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("failed to read SFV file: %w", err)
	}
	
	return checksums, nil
}

// UpdateSFV updates an existing SFV file with new checksums
func (g *Generator) UpdateSFV(sfvPath string, filePaths []string) error {
	// Read existing SFV
	existing, err := g.ReadSFV(sfvPath)
	if err != nil {
		return err
	}
	
	// Calculate new checksums
	newChecksums := make(map[string]string)
	for _, filePath := range filePaths {
		checksum, err := g.calculateCRC32(filePath)
		if err != nil {
			return fmt.Errorf("failed to calculate checksum for %s: %w", filePath, err)
		}
		
		relPath, err := filepath.Rel(filepath.Dir(sfvPath), filePath)
		if err != nil {
			relPath = filepath.Base(filePath)
		}
		
		newChecksums[relPath] = fmt.Sprintf("%08X", checksum)
	}
	
	// Merge checksums
	for k, v := range newChecksums {
		existing[k] = v
	}
	
	// Write updated SFV
	file, err := os.Create(sfvPath)
	if err != nil {
		return fmt.Errorf("failed to create SFV file: %w", err)
	}
	defer file.Close()

	writer := bufio.NewWriter(file)
	defer writer.Flush()

	// Write SFV header
	_, err = writer.WriteString("; Updated by Usenet Poster\n")
	if err != nil {
		return fmt.Errorf("failed to write SFV header: %w", err)
	}

	// Write all checksums
	for fileName, checksum := range existing {
		_, err = writer.WriteString(fmt.Sprintf("%s %s\n", fileName, checksum))
		if err != nil {
			return fmt.Errorf("failed to write SFV entry: %w", err)
		}
	}

	return nil
}